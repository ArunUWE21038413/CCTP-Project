using UnityEngine;

public class PerlinNoiseGenerator : MonoBehaviour
{
    [Header("Texture Settings")]
    public int textureWidth = 256;  // Width of the texture
    public int textureHeight = 256; // Height of the texture
    public float scale = 20f;       // Scale of the noise pattern
    public float offsetX = 0f;      // Horizontal offset
    public float offsetY = 0f;      // Vertical offset

    [Header("Noise Parameters")]
    [Range(1, 8)]
    public int octaves = 1;         // Number of layers of noise
    [Range(0f, 1f)]
    public float persistence = 0.5f; // Controls amplitude reduction with each octave
    public float lacunarity = 2.0f; // Controls frequency increase with each octave

    [Header("Terrain Types")]
    public bool isGreenland = true;      // Enable green farmlands (green color)
    public bool isCropland = true;       // Enable cropland (yellowish-brown color)
    public bool isPond = true;           // Enable water ponds (blue-green color)

    [Header("Terrain Distribution")]
    [Range(0f, 1f)] public float greenlandPercentage = 0.8f; // Percentage of Greenlands
    [Range(0f, 1f)] public float croplandPercentage = 0.15f; // Percentage of Croplands
    [Range(0f, 1f)] public float pondPercentage = 0.05f; // Percentage of Ponds

    [Header("Options")]
    public bool showPreview = true;     // Toggle to show or hide preview in the scene
    public bool autoUpdate = true;      // Automatically update the texture when parameters change
    public bool enableInBuild = false;  // Controls whether the noise generation is active in builds (false by default)

    private Texture2D noiseTexture; // The texture generated by Perlin noise
    private Renderer renderer;      // Renderer component to apply the texture

    void Start()
    {
        renderer = GetComponent<Renderer>();
        if (autoUpdate)
        {
            GenerateNoiseTexture(); // Initial texture generation
        }

        // Only allow the Perlin noise generation in the editor, but not in builds (unless enabled via the inspector).
        if (!enableInBuild && !Application.isEditor)
        {
            enabled = false; // Disable the script in builds if 'enableInBuild' is false.
        }
    }

    /// <summary>
    /// Generates the Perlin noise texture with the specified parameters.
    /// </summary>
    void GenerateNoiseTexture()
    {
        // Create a new texture if it doesn't exist yet
        noiseTexture = new Texture2D(textureWidth, textureHeight);

        // Loop through each pixel of the texture
        for (int x = 0; x < textureWidth; x++)
        {
            for (int y = 0; y < textureHeight; y++)
            {
                // Calculate Perlin noise value using multiple octaves
                float noiseValue = CalculatePerlinNoise(x, y);

                // Get the color based on noise value and terrain distribution
                Color pixelColor = GetTerrainColor(noiseValue);

                // Set the pixel color based on the terrain type
                noiseTexture.SetPixel(x, y, pixelColor);
            }
        }

        // Apply the changes to the texture
        noiseTexture.Apply();

        // Assign the generated texture to the material
        renderer.material.mainTexture = noiseTexture;
    }

    /// <summary>
    /// Calculates Perlin noise with multiple octaves.
    /// </summary>
    /// <param name="x">The x-coordinate of the pixel.</param>
    /// <param name="y">The y-coordinate of the pixel.</param>
    /// <returns>The calculated Perlin noise value.</returns>
    float CalculatePerlinNoise(int x, int y)
    {
        float noiseValue = 0f;
        float amplitude = 1f;
        float frequency = 1f;
        float maxAmplitude = 0f; // Used for normalization

        // Loop through each octave (layer of noise)
        for (int i = 0; i < octaves; i++)
        {
            float xCoord = (x / (float)textureWidth * scale * frequency) + offsetX;
            float yCoord = (y / (float)textureHeight * scale * frequency) + offsetY;

            noiseValue += Mathf.PerlinNoise(xCoord, yCoord) * amplitude;

            maxAmplitude += amplitude;
            amplitude *= persistence; // Reduce amplitude for each octave
            frequency *= lacunarity;  // Increase frequency for each octave
        }

        // Normalize the final noise value to be between 0 and 1
        return noiseValue / maxAmplitude;
    }

    /// <summary>
    /// Determines the color of the terrain based on the noise value.
    /// </summary>
    /// <param name="noiseValue">The Perlin noise value between 0 and 1.</param>
    /// <returns>The color to be applied to the pixel.</returns>
    Color GetTerrainColor(float noiseValue)
    {
        // Determine which terrain type should be applied based on noise value and the distribution percentages
        if (isGreenland && noiseValue < greenlandPercentage) // Greenlands (80%)
        {
            return Color.green;  // Green for farmlands
        }
        else if (isCropland && noiseValue >= greenlandPercentage && noiseValue < (greenlandPercentage + croplandPercentage)) // Croplands (15%)
        {
            return new Color(0.6f, 0.4f, 0.2f); // Yellowish-brown for croplands (as requested)
        }
        else if (isPond && noiseValue >= (greenlandPercentage + croplandPercentage) && noiseValue < 1f) // Ponds (5%)
        {
            return new Color(0.3f, 0.5f, 0.8f); // Blue-green for ponds
        }

        return Color.white; // Default white if none of the conditions match
    }

    void Update()
    {
        // Regenerate the noise texture if Auto Update is enabled
        if (autoUpdate)
        {
            GenerateNoiseTexture();
        }
    }

    /// <summary>
    /// Show preview in the Scene view (wireframe cube).
    /// </summary>
    void OnDrawGizmos()
    {
        if (showPreview && noiseTexture != null)
        {
            Gizmos.color = Color.white;
            Gizmos.DrawWireCube(transform.position, new Vector3(1, 0, 1));
        }
    }
}
